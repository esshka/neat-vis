<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEAT Network Visualization with Babylon.js</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: Arial, sans-serif;
        }
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        button {
            margin: 5px;
            padding: 5px 10px;
            background: #333;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>NEAT Network Visualization</h2>
        <p>Node colors: Blue (Input) | Green (Hidden) | Red (Output)</p>
        <p>Connection colors:<br>
           - Blue to Red: Weight strength (negative to positive)<br>
           - Yellow: Recurrent connections<br>
           - Gray: Disabled connections
        </p>
        <p>Gating influences: Dashed lines from neurons to connection midpoints, colored by gating strength (blue to red)</p>
    </div>
    <div id="controls">
        <button id="resetButton">Reset View</button>
        <button id="toggleSimulation">Pause Layout</button>
    </div>
    <script>
        // NEAT network data structure with recurrent connections and gating
        const network = {
            nodes: [
                // Input nodes
                { id: 0, type: 'input' },
                { id: 1, type: 'input' },
                { id: 2, type: 'input' },
                { id: 3, type: 'input' },
                { id: 4, type: 'input' },
                { id: 5, type: 'input' },
                // Hidden nodes - multiple layers
                { id: 6, type: 'hidden' },
                { id: 7, type: 'hidden' },
                { id: 8, type: 'hidden' },
                { id: 9, type: 'hidden' },
                { id: 10, type: 'hidden' },
                { id: 11, type: 'hidden' },
                { id: 12, type: 'hidden' },
                { id: 13, type: 'hidden' },
                { id: 14, type: 'hidden' },
                { id: 15, type: 'hidden' },
                // Output nodes
                { id: 16, type: 'output' },
                { id: 17, type: 'output' },
                { id: 18, type: 'output' },
                { id: 19, type: 'output' }
            ],
            connections: [
                // Input to first hidden layer with gating
                { source: 0, target: 6, weight: 0.8, enabled: true, gating: [{ neuron: 7, strength: 0.5 }, { neuron: 8, strength: -0.3 }] },
                { source: 0, target: 7, weight: -0.5, enabled: true },
                { source: 0, target: 8, weight: 0.3, enabled: true },
                { source: 1, target: 6, weight: -0.4, enabled: true, gating: [{ neuron: 9, strength: 0.4 }] },
                { source: 1, target: 7, weight: 0.6, enabled: true },
                { source: 1, target: 9, weight: 0.2, enabled: true },
                { source: 2, target: 7, weight: -0.7, enabled: true },
                { source: 2, target: 8, weight: 0.5, enabled: true },
                { source: 2, target: 9, weight: -0.3, enabled: true },
                { source: 3, target: 8, weight: 0.4, enabled: true },
                { source: 3, target: 9, weight: -0.6, enabled: true },
                { source: 3, target: 10, weight: 0.3, enabled: true },
                { source: 4, target: 9, weight: 0.7, enabled: true },
                { source: 4, target: 10, weight: -0.4, enabled: true },
                { source: 5, target: 10, weight: 0.6, enabled: true },
                // Connections between hidden layers with gating
                { source: 6, target: 11, weight: 0.5, enabled: true, gating: [{ neuron: 12, strength: -0.2 }] },
                { source: 6, target: 12, weight: -0.3, enabled: true },
                { source: 7, target: 11, weight: 0.4, enabled: true },
                { source: 7, target: 12, weight: 0.6, enabled: true },
                { source: 8, target: 12, weight: -0.5, enabled: true },
                { source: 8, target: 13, weight: 0.7, enabled: true },
                { source: 9, target: 13, weight: -0.4, enabled: true },
                { source: 9, target: 14, weight: 0.3, enabled: true },
                { source: 10, target: 14, weight: 0.6, enabled: true },
                { source: 10, target: 15, weight: -0.5, enabled: true },
                // Recurrent connections (hidden to hidden)
                { source: 11, target: 7, weight: 0.2, enabled: true, recurrent: true },
                { source: 12, target: 8, weight: -0.3, enabled: true, recurrent: true },
                { source: 13, target: 9, weight: 0.1, enabled: true, recurrent: true },
                { source: 14, target: 10, weight: -0.2, enabled: true, recurrent: true },
                // Hidden to output connections with gating
                { source: 11, target: 16, weight: 0.8, enabled: true, gating: [{ neuron: 13, strength: 0.3 }] },
                { source: 11, target: 17, weight: -0.4, enabled: true },
                { source: 12, target: 16, weight: 0.5, enabled: true },
                { source: 12, target: 18, weight: 0.6, enabled: true },
                { source: 13, target: 17, weight: -0.3, enabled: true },
                { source: 13, target: 19, weight: 0.7, enabled: true },
                { source: 14, target: 18, weight: 0.4, enabled: true },
                { source: 14, target: 19, weight: -0.5, enabled: true },
                { source: 15, target: 18, weight: 0.3, enabled: true },
                { source: 15, target: 19, weight: 0.6, enabled: true },
                // Direct input to output connections (some disabled)
                { source: 0, target: 16, weight: 0.2, enabled: false },
                { source: 1, target: 17, weight: -0.3, enabled: false },
                { source: 2, target: 18, weight: 0.4, enabled: false },
                { source: 3, target: 19, weight: 0.1, enabled: false },
                // Additional cross-layer connections
                { source: 6, target: 14, weight: 0.3, enabled: true },
                { source: 7, target: 15, weight: -0.4, enabled: true },
                { source: 8, target: 16, weight: 0.5, enabled: true },
                { source: 9, target: 17, weight: -0.2, enabled: true },
                { source: 10, target: 18, weight: 0.6, enabled: true }
            ]
        };

        // Calculate node counts
        const numInputs = network.nodes.filter(node => node.type === 'input').length;
        const numOutputs = network.nodes.filter(node => node.type === 'output').length;
        const numHidden = network.nodes.length - numInputs - numOutputs;

        // Babylon.js setup
        const canvas = document.createElement('canvas');
        document.body.appendChild(canvas);
        const engine = new BABYLON.Engine(canvas, true);
        const scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0.07, 0.07, 0.07, 1); // Dark gray background

        // Set up camera
        const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2, 10, BABYLON.Vector3.Zero(), scene);
        camera.attachControl(canvas, true);

        // Set up lighting
        const ambientLight = new BABYLON.HemisphericLight("ambientLight", new BABYLON.Vector3(0, 1, 0), scene);
        ambientLight.intensity = 0.5;
        const directionalLight = new BABYLON.DirectionalLight("directionalLight", new BABYLON.Vector3(1, -1, -1), scene);
        directionalLight.intensity = 1.0;

        // Node visualization
        const nodeMeshes = [];
        const nodePositions = [];
        const velocities = [];
        const idToIndex = {};

        // Define materials
        const inputMaterial = new BABYLON.StandardMaterial("inputMaterial", scene);
        inputMaterial.diffuseColor = new BABYLON.Color3(0, 0.4, 1); // Blue
        const hiddenMaterial = new BABYLON.StandardMaterial("hiddenMaterial", scene);
        hiddenMaterial.diffuseColor = new BABYLON.Color3(0, 1, 0.4); // Green
        const outputMaterial = new BABYLON.StandardMaterial("outputMaterial", scene);
        outputMaterial.diffuseColor = new BABYLON.Color3(1, 0.2, 0.2); // Red

        // Create nodes
        const spacing = 1.0;
        let inputCounter = 0;
        let outputCounter = 0;

        network.nodes.forEach((node, index) => {
            idToIndex[node.id] = index;
            let material;
            if (node.type === 'input') material = inputMaterial;
            else if (node.type === 'hidden') material = hiddenMaterial;
            else material = outputMaterial;

            const mesh = BABYLON.MeshBuilder.CreateSphere(`node_${node.id}`, { diameter: 0.4 }, scene);
            mesh.material = material;

            let pos;
            if (node.type === 'input') {
                pos = new BABYLON.Vector3(-5, (inputCounter - (numInputs - 1) / 2) * spacing, 0);
                inputCounter++;
            } else if (node.type === 'output') {
                pos = new BABYLON.Vector3(5, (outputCounter - (numOutputs - 1) / 2) * spacing, 0);
                outputCounter++;
            } else {
                pos = new BABYLON.Vector3((Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6);
            }

            mesh.position = pos;
            nodeMeshes.push(mesh);
            nodePositions.push(pos);
            velocities.push(new BABYLON.Vector3(0, 0, 0));
        });

        // Connection visualization
        let minWeight = Infinity;
        let maxWeight = -Infinity;
        network.connections.forEach(conn => {
            if (conn.enabled) {
                minWeight = Math.min(minWeight, conn.weight);
                maxWeight = Math.max(maxWeight, conn.weight);
            }
        });
        if (minWeight === Infinity) minWeight = 0;
        if (maxWeight === -Infinity) maxWeight = 0;

        let minGatingStrength = Infinity;
        let maxGatingStrength = -Infinity;
        network.connections.forEach(conn => {
            if (conn.gating) {
                conn.gating.forEach(gate => {
                    minGatingStrength = Math.min(minGatingStrength, gate.strength);
                    maxGatingStrength = Math.max(maxGatingStrength, gate.strength);
                });
            }
        });
        if (minGatingStrength === Infinity) minGatingStrength = 0;
        if (maxGatingStrength === -Infinity) maxGatingStrength = 0;

        function getConnectionColorAndOpacity(conn) {
            let color;
            let opacity = 1.0;
            if (!conn.enabled) {
                color = new BABYLON.Color3(0.33, 0.33, 0.33); // Gray
                opacity = 0.3;
            } else {
                if (conn.recurrent) {
                    color = new BABYLON.Color3(1, 1, 0); // Yellow
                } else if (conn.weight < 0) {
                    const intensity = minWeight !== 0 ? Math.abs(conn.weight) / Math.abs(minWeight) : 0;
                    color = new BABYLON.Color3(0, 0, 1 - intensity * 0.5);
                } else if (conn.weight > 0) {
                    const intensity = maxWeight !== 0 ? conn.weight / maxWeight : 0;
                    color = new BABYLON.Color3(intensity, 0, 0);
                } else {
                    color = new BABYLON.Color3(0.5, 0.5, 0.5); // Gray
                }
                const weightStrength = Math.abs(conn.weight) / Math.max(Math.abs(minWeight), maxWeight);
                opacity = 0.7 + 0.3 * weightStrength;
            }
            return { color, opacity };
        }

        function getGatingColor(gate) {
            let color;
            if (gate.strength < 0) {
                const intensity = minGatingStrength !== 0 ? Math.abs(gate.strength) / Math.abs(minGatingStrength) : 0;
                color = new BABYLON.Color3(0, 0, 1 - intensity * 0.5);
            } else if (gate.strength > 0) {
                const intensity = maxGatingStrength !== 0 ? gate.strength / maxGatingStrength : 0;
                color = new BABYLON.Color3(intensity, 0, 0);
            } else {
                color = new BABYLON.Color3(0.5, 0.5, 0.5);
            }
            return color;
        }

        let connectionLines = [];
        let gatingLines = [];

        function updateConnections() {
            connectionLines.forEach(line => line.dispose());
            gatingLines.forEach(line => line.dispose());
            connectionLines = [];
            gatingLines = [];

            // Main connections
            network.connections.forEach(conn => {
                const sourceIndex = idToIndex[conn.source];
                const targetIndex = idToIndex[conn.target];
                const sourcePos = nodePositions[sourceIndex];
                const targetPos = nodePositions[targetIndex];
                const points = [sourcePos.clone(), targetPos.clone()];
                const { color, opacity } = getConnectionColorAndOpacity(conn);
                const line = BABYLON.MeshBuilder.CreateLines(`conn_${conn.source}_${conn.target}`, { points }, scene);
                line.color = color;
                line.alpha = opacity;
                connectionLines.push(line);
            });

            // Gating influences
            network.connections.forEach(conn => {
                if (conn.gating && conn.gating.length > 0) {
                    const sourceIndex = idToIndex[conn.source];
                    const targetIndex = idToIndex[conn.target];
                    const sourcePos = nodePositions[sourceIndex];
                    const targetPos = nodePositions[targetIndex];
                    const midpoint = BABYLON.Vector3.Center(sourcePos, targetPos);
                    conn.gating.forEach(gate => {
                        const gatingNeuronIndex = idToIndex[gate.neuron];
                        const gatingPos = nodePositions[gatingNeuronIndex];
                        const points = [gatingPos.clone(), midpoint.clone()];
                        const color = getGatingColor(gate);
                        const line = BABYLON.MeshBuilder.CreateDashedLines(`gate_${gate.neuron}_${conn.source}_${conn.target}`, { points, dashSize: 0.1, gapSize: 0.1 }, scene);
                        line.color = color;
                        line.alpha = 0.5;
                        gatingLines.push(line);
                    });
                }
            });
        }

        // Force-directed layout
        const params = {
            repulsionStrength: 1.0,
            attractionStrength: 0.03,
            damping: 0.85,
            timeStep: 0.1,
            stabilizationThreshold: 0.01
        };

        let simulating = true;
        const toggleSimulationButton = document.getElementById('toggleSimulation');

        function updateForces() {
            if (!simulating) return;

            const forces = Array(network.nodes.length).fill().map(() => new BABYLON.Vector3(0, 0, 0));

            // Repulsion
            for (let i = 0; i < network.nodes.length; i++) {
                for (let j = i + 1; j < network.nodes.length; j++) {
                    const posI = nodePositions[i];
                    const posJ = nodePositions[j];
                    const direction = posI.subtract(posJ);
                    const distance = direction.length();
                    if (distance > 0.1) {
                        const repulsionForce = params.repulsionStrength / (distance * distance);
                        direction.normalize().scaleInPlace(repulsionForce);
                        forces[i].addInPlace(direction);
                        forces[j].subtractInPlace(direction);
                    }
                }
            }

            // Attraction
            network.connections.forEach(conn => {
                if (conn.enabled) {
                    const sourceIndex = idToIndex[conn.source];
                    const targetIndex = idToIndex[conn.target];
                    const posSource = nodePositions[sourceIndex];
                    const posTarget = nodePositions[targetIndex];
                    const direction = posTarget.subtract(posSource);
                    const distance = direction.length();
                    direction.normalize().scaleInPlace(params.attractionStrength * distance);
                    forces[sourceIndex].addInPlace(direction);
                    forces[targetIndex].subtractInPlace(direction);
                }
            });

            // Update velocities and positions for hidden nodes
            let totalVelocity = 0;
            for (let i = 0; i < network.nodes.length; i++) {
                if (network.nodes[i].type === 'hidden') {
                    velocities[i].addInPlace(forces[i]);
                    velocities[i].scaleInPlace(params.damping);
                    const delta = velocities[i].scale(params.timeStep);
                    nodePositions[i].addInPlace(delta);
                    nodeMeshes[i].position = nodePositions[i];
                    totalVelocity += velocities[i].length();
                }
            }

            if (totalVelocity < params.stabilizationThreshold * numHidden) {
                console.log("Layout stabilized");
                simulating = false;
                toggleSimulationButton.textContent = 'Resume Layout';
            }

            updateConnections();
        }

        // UI interactions
        function resetView() {
            camera.setPosition(new BABYLON.Vector3(0, 0, 10));
            camera.setTarget(BABYLON.Vector3.Zero());
        }

        document.getElementById('resetButton').addEventListener('click', resetView);
        toggleSimulationButton.addEventListener('click', () => {
            simulating = !simulating;
            toggleSimulationButton.textContent = simulating ? 'Pause Layout' : 'Resume Layout';
        });

        // Window resize
        window.addEventListener('resize', () => {
            engine.resize();
        });

        // Initialize connections
        updateConnections();

        // Render loop
        engine.runRenderLoop(() => {
            updateForces();
            scene.render();
        });
    </script>
</body>
</html>